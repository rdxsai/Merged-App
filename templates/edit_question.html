<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Question - Canvas Quiz Manager</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <!-- SimpleMDE CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.css">
    <style>
        .form-control:focus {
            border-color: #0d6efd;
            box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
        }
        .answer-item {
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
        .answer-weight {
            background-color: #e9ecef;
        }
        .feedback-section {
            background-color: #f8f9fa;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .progress-container {
            background-color: #f8f9fa;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .progress-bar-custom {
            background: linear-gradient(45deg, #0d6efd, #20c997);
        }
        .navigation-buttons .btn {
            min-width: 100px;
        }
        .tag-suggestion:hover {
            background-color: #f8f9fa !important;
        }
        #tagSuggestions {
            max-height: 200px;
            overflow-y: auto;
        }
        .answer-feedback-editor .CodeMirror {
            min-height: 100px;
        }
        
        /* Ensure code blocks display properly in both preview sections */
        .question-text-preview pre,
        .question-preview pre {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin: 1rem 0;
            overflow-x: auto;
        }
        
        .question-text-preview code,
        .question-preview code {
            background-color: #f8f9fa;
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.875em;
        }
        
        .question-text-preview pre code,
        .question-preview pre code {
            background-color: transparent;
            padding: 0;
            border-radius: 0;
            display: block;
            white-space: pre;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <!-- Auto-save indicator -->
        <div id="autoSaveIndicator" class="auto-save-indicator" style="display: none;">
            <div class="alert alert-success alert-sm mb-0">
                <i class="fas fa-check"></i> Saved
            </div>
        </div>

        <div class="row">
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <h1 class="h2">
                        {% if is_new_question %}
                        <i class="fas fa-plus text-success"></i> Create New Question
                        <small class="text-muted fs-6">({{ total_questions }} questions in database)</small>
                        {% else %}
                        <i class="fas fa-edit text-primary"></i> Edit Question
                        <small class="text-muted fs-6">({{ current_position }} of {{ total_questions }})</small>
                        {% endif %}
                    </h1>
                        <div class="btn-group navigation-buttons">
                        {% if prev_question_id %}
                        <a href="/questions/{{ prev_question_id }}" class="btn btn-outline-secondary" id="prevBtn">
                            <i class="fas fa-chevron-left"></i> Previous
                        </a>
                        {% else %}
                        <button class="btn btn-outline-secondary" disabled>
                            <i class="fas fa-chevron-left"></i> Previous
                        </button>
                        {% endif %}
                        
                        <a href="/" class="btn btn-outline-secondary">
                            <i class="fas fa-list"></i> Home
                        </a>
                        
                        <a href="/questions/new" class="btn btn-success">
                            <i class="fas fa-plus"></i> New
                        </a>
                        
                        {% if not is_new_question %}
                        <button type="button" class="btn btn-danger" id="deleteQuestionBtn" data-question-id="{{ question.id }}">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                        {% endif %}
                        
                        {% if next_question_id %}
                        <a href="/questions/{{ next_question_id }}" class="btn btn-outline-secondary" id="nextBtn">
                            Next <i class="fas fa-chevron-right"></i>
                        </a>
                        {% else %}
                        <button class="btn btn-outline-secondary" disabled>
                            Next <i class="fas fa-chevron-right"></i>
                        </button>
                        {% endif %}
                    </div>
                </div>

                <!-- Progress indicator -->
                {% if not is_new_question %}
                <div class="progress-container">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <span class="text-muted">Question Progress</span>
                        <span class="badge bg-primary">{{ current_position }} / {{ total_questions }}</span>
                    </div>
                    <div class="progress">
                        {% set progress_percent = (((current_position or 0) / (total_questions or 1)) * 100) | round(1) if total_questions else 0 %}
                        <div class="progress-bar progress-bar-custom" role="progressbar" 
                             data-progress="{{ progress_percent }}"
                             aria-valuenow="{{ current_position or 0 }}" 
                             aria-valuemin="0" 
                             aria-valuemax="{{ total_questions or 1 }}">
                        </div>
                    </div>
                </div>
                {% else %}
                <div class="progress-container">
                    <div class="alert alert-info">
                        <h6 class="alert-heading">
                            <i class="fas fa-info-circle"></i> Creating New Question
                        </h6>
                        <p class="mb-2">Fill out the question details below. The question will be saved automatically as you type.</p>
                        <button id="manualSaveBtn" class="btn btn-success btn-sm">
                            <i class="fas fa-save"></i> Save Question Now
                        </button>
                    </div>
                </div>
                {% endif %}

                <!-- Question Preview -->
                <div class="card mb-4">
                    <div class="card-header">
                        <h5 class="mb-0">
                            <i class="fas fa-eye text-info"></i> Question Preview
                        </h5>
                    </div>
                    <div class="card-body">
                        <div class="question-preview">
                            <div class="mb-3">
                                <strong>{{ question.question_type.replace('_', ' ').title() }}</strong>
                                <span class="badge bg-secondary ms-2">{{ question.points_possible }} points</span>
                                <span class="badge bg-info ms-2" id="topicPreview">
                                    <i class="fas fa-tag"></i> 
                                    {% for value, label in available_topics %}
                                        {% if question.topic == value %}{{ label }}{% endif %}
                                    {% endfor %}
                                </span>
                                <span id="tagsPreview" class="ms-2" {% if not question.tags %}style="display: none;"{% endif %}>
                                    {% if question.tags %}
                                        {% for tag in question.tags.split(',') %}
                                            {% if tag.strip() %}
                                                <span class="badge bg-secondary me-1">{{ tag.strip() }}</span>
                                            {% endif %}
                                        {% endfor %}
                                    {% endif %}
                                </span>
                                <span id="objectivePreview" class="ms-2" {% if not question.learning_objective %}style="display: none;"{% endif %}>
                                    {% if question.learning_objective and learning_objectives %}
                                        {% set objective_index = question.learning_objective | int %}
                                        {% if objective_index < learning_objectives|length %}
                                            <span class="badge bg-warning text-dark">
                                                <i class="fas fa-bullseye"></i> Obj {{ objective_index + 1 }}
                                            </span>
                                        {% endif %}
                                    {% endif %}
                                </span>
                            </div>
                            <div class="question-text-preview mb-3">
                                {{ question_text_html | safe }}
                            </div>
                            {% if question.answers %}
                            <div class="answers-preview">
                                <h6>Answer Options:</h6>
                                <div class="list-group">
                                    {% for answer in question.answers %}
                                    <div class="list-group-item d-flex justify-content-between align-items-start">
                                        <div class="ms-2 me-auto">
                                            {% set _text = (answer.text or '') %}
                                            {% set _html = (answer.html or '') %}
                                            {% set display_text = (answer.text if answer.text and answer.text|trim else (answer.html|default('')|striptags)) %}
                                            <div class="fw-bold">
                                                {% if question.question_type == 'matching_question' %}
                                                <i class="fas fa-link text-info"></i>
                                                {% elif answer.weight is defined and answer.weight > 0 %}
                                                <i class="fas fa-check-circle text-success"></i>
                                                {% else %}
                                                <i class="fas fa-circle text-muted"></i>
                                                {% endif %}
                                                {{ display_text | escape }}
                                                {% if question.question_type == 'matching_question' and answer.right %}
                                                <br><small class="text-muted">→ {{ answer.right | escape}}</small>
                                                {% endif %}
                                            </div>
                                            {% if answer.html %}
                                            
                                            {% endif %}
                                        </div>
                                        {% if question.question_type == 'matching_question' %}
                                        <span class="badge bg-info rounded-pill">Match</span>
                                        {% elif answer.weight is defined %}
                                        <span class="badge bg-primary rounded-pill">{{ answer.weight }}%</span>
                                        {% else %}
                                        <span class="badge bg-secondary rounded-pill">N/A</span>
                                        {% endif %}
                                    </div>
                                    {% endfor %}
                                </div>
                            </div>
                            {% endif %}
                        </div>
                    </div>
                </div>

                <form id="questionForm">
                    <!-- Question Basic Info -->
                    <div class="card mb-4">
                        <div class="card-header">
                            <h5 class="mb-0">
                                <i class="fas fa-question-circle"></i> Question Details
                            </h5>
                        </div>
                        <div class="card-body">
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label class="form-label"><strong>Question ID:</strong></label>
                                    <input type="text" class="form-control" value="{% if is_new_question %}Will be assigned after saving{% else %}{{ question.id }}{% endif %}" readonly>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label"><strong>Type:</strong></label>
                                    <input type="text" class="form-control" value="{{ question.question_type.replace('_', ' ').title() }}" readonly>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label for="questionText" class="form-label"><strong>Question Text:</strong></label>
                                <textarea id="questionText" name="question_text" class="form-control" rows="4">{{ question.question_text }}</textarea>
                            </div>
                            <div class="row mb-3">
                                <div class="col-md-6">
                                    <label class="form-label"><strong>Points Possible:</strong></label>
                                    <input type="text" class="form-control" value="{{ question.points_possible }}" readonly>
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label"><strong>Quiz ID:</strong></label>
                                    <input type="text" class="form-control" value="{{ question.quiz_id }}" readonly>
                                </div>
                            </div>
                            <div class="row mb-3">
                                <div class="col-md-4">
                                    <label for="topicSelect" class="form-label"><strong>Topic:</strong></label>
                                    <select id="topicSelect" name="topic" class="form-select">
                                        {% for value, label in available_topics %}
                                        <option value="{{ value }}" {% if question.topic == value %}selected{% endif %}>
                                            {{ label }}
                                        </option>
                                        {% endfor %}
                                    </select>
                                </div>
                                <div class="col-md-4">
                                    <label for="learningObjectiveSelect" class="form-label"><strong>Learning Objective:</strong></label>
                                    <select id="learningObjectiveSelect" name="learning_objective" class="form-select">
                                        <option value="">Select Learning Objective...</option>
                                        {% for objective in learning_objectives %}
                                        <option value="{{ loop.index0 }}" {% if question.learning_objective == loop.index0|string %}selected{% endif %}>
                                            Objective {{ loop.index }}: {{ objective.text[:60] }}{% if objective.text|length > 60 %}...{% endif %}
                                        </option>
                                        {% endfor %}
                                    </select>
                                    {% if not learning_objectives %}
                                    <small class="text-muted">
                                        <i class="fas fa-info-circle"></i> 
                                        <a href="/objectives" target="_blank">Create learning objectives</a> to link questions
                                    </small>
                                    {% endif %}
                                </div>
                                <div class="col-md-4">
                                    <label for="tagsInput" class="form-label"><strong>Tags:</strong></label>
                                    <div class="position-relative">
                                        <input type="text" id="tagsInput" name="tags" class="form-control" 
                                               value="{{ question.tags }}" 
                                               placeholder="comma, separated, tags"
                                               autocomplete="off">
                                        <div id="tagSuggestions" class="position-absolute w-100 bg-white border border-top-0 rounded-bottom shadow-sm" 
                                             style="display: none; z-index: 1000; max-height: 200px; overflow-y: auto;">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Question Feedback -->
                    <div class="card mb-4">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">
                                <i class="fas fa-lightbulb text-warning"></i> General Question Feedback
                            </h5>
                            <button type="button" id="generateFeedbackBtn" class="btn btn-success btn-sm">
                                <i class="fas fa-magic"></i> Generate AI Feedback
                            </button>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label for="generalFeedback" class="form-label">
                                    <strong>Importance and Relevance:</strong>
                                </label>
                                <textarea id="generalFeedback" name="general_feedback" class="form-control" rows="4" 
                                    placeholder="Explain the importance and relevance of this question. Why is this concept important for students to understand? How does it relate to the course material?">{{ question.neutral_comments }}</textarea>
                                <div class="form-text">
                                    This field is for explaining why this question is important and how it relates to the broader course content.
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Answers -->
                    {% if question.answers %}
                    <div class="card mb-4">
                        <div class="card-header">
                            <h5 class="mb-0">
                                <i class="fas fa-list"></i> Answers ({{ question.answers|length }})
                            </h5>
                        </div>
                        <div class="card-body">
                            <div id="answersContainer">
                                {% for answer in question.answers %}
                                <div class="answer-item p-3" data-answer-id="{{ answer.id }}">
                                    <div class="row">
                                        {% if question.question_type != 'matching_question' %}
                                        <div class="col-md-1">
                                            <label class="form-label">Correct:</label>
                                            <div class="text-center">
                                                <button type="button" class="btn btn-sm correctness-button {% if answer.weight is defined and answer.weight > 0 %}btn-success{% else %}btn-danger{% endif %}" 
                                                        data-answer-id="{{ answer.id }}" 
                                                        data-question-type="{{ question.question_type }}"
                                                        style="color: white; border: none; min-width: 60px;"
                                                        title="Click to toggle correctness">
                                                    {% if answer.weight is defined and answer.weight > 0 %}True{% else %}False{% endif %}
                                                </button>
                                            </div>
                                        </div>
                                        <div class="col-md-1">
                                            <label class="form-label">Weight:</label>
                                            <input type="number" name="answer_weight_{{ answer.id }}" class="form-control answer-weight" value="{{ answer.weight if answer.weight is defined else 0 }}" step="0.1" readonly>
                                        </div>
                                        <div class="col-md-10">
                                        {% else %}
                                        <div class="col-md-12">
                                        {% endif %}
                                            <label class="form-label">{% if question.question_type == 'matching_question' %}Left Side (Item to Match):{% else %}Answer Text:{% endif %}</label>
                                            <textarea name="answer_text_{{ answer.id }}" class="form-control answer-text-editor" rows="2">{{ answer.text }}</textarea>
                                        </div>
                                    </div>
                                    
                                    {% if question.question_type == 'matching_question' and answer.right %}
                                    <div class="mb-2">
                                        <label class="form-label">Right Side (Match Target):</label>
                                        <textarea name="answer_right_{{ answer.id }}" class="form-control" rows="2">{{ answer.right }}</textarea>
                                    </div>
                                    {% endif %}
                                    
                                    {% if answer.html %}
                                    <div class="mb-2">
                                        <label class="form-label">HTML:</label>
                                        <textarea name="answer_html_{{ answer.id }}" class="form-control" rows="2">{{ answer.html }}</textarea>
                                    </div>
                                    {% endif %}

                                    <div class="mb-2">
                                        <label class="form-label">Answer Feedback:</label>
                                        <textarea name="answer_comments_{{ answer.id }}" class="form-control answer-feedback-editor" rows="3" 
                                            placeholder="Feedback specific to this answer choice - explain why it's correct/incorrect">{{ answer.comments }}</textarea>
                                        <div class="form-text">
                                            Provide specific feedback about why this answer choice is correct or incorrect.
                                        </div>
                                    </div>

                                    {% if answer.comments_html %}
                                    <div class="mb-2">
                                        <label class="form-label">Answer Feedback HTML:</label>
                                        <textarea name="answer_comments_html_{{ answer.id }}" class="form-control" rows="2">{{ answer.comments_html }}</textarea>
                                    </div>
                                    {% endif %}
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                    {% endif %}
                </form>
            </div>
        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal fade" id="deleteQuestionModal" tabindex="-1" aria-labelledby="deleteQuestionModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-danger text-white">
                    <h5 class="modal-title" id="deleteQuestionModalLabel">
                        <i class="fas fa-exclamation-triangle"></i> Delete Question
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p class="mb-3">Are you sure you want to delete this question?</p>
                    <div class="alert alert-warning">
                        <strong><i class="fas fa-info-circle"></i> Warning:</strong>
                        This action cannot be undone. The question and all its answers will be permanently removed from the database.
                    </div>
                    <div class="question-summary p-3 bg-light border rounded" id="deleteQuestionSummary">
                        <!-- Question summary will be populated by JavaScript -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                    <button type="button" class="btn btn-danger" id="confirmDeleteBtn">
                        <i class="fas fa-trash"></i> Delete Question
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Configuration data -->
    <div id="app-config" 
         data-question-id="{% if is_new_question %}new{% else %}{{ question.id }}{% endif %}"
         data-is-new-question="{{ 'true' if is_new_question else 'false' }}"
         style="display: none;"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- SimpleMDE JS -->
    <script src="https://cdn.jsdelivr.net/simplemde/latest/simplemde.min.js"></script>
    <script>
    function escapeHtml(unsafe) {
    if (!unsafe) return '';
    return unsafe
         .replace(/&/g, "&amp;")
         .replace(/</g, "&lt;")
         .replace(/>/g, "&gt;")
         .replace(/"/g, "&quot;")
         .replace(/'/g, "&#039;");
}
        // Get configuration from data attributes
        const configElement = document.getElementById('app-config');
        const questionId = configElement.dataset.questionId;
        const isNewQuestion = configElement.dataset.isNewQuestion === 'true';
        let currentQuestionId = questionId;
        
        let saveTimeout;
        let isSaving = false;
        let isGeneratingFeedback = false;
        
        // Initialize SimpleMDE editors
        let questionTextEditor;
        let generalFeedbackEditor;
        let answerFeedbackEditors = [];
        let answerTextEditors = [];


        function initializeAnswerTextEditors(){
            const textTextareas = document.querySelectorAll('.answer-text-editor');
            textTextareas.forEach((textarea, index) => {
                const editor = new SimpleMDE({
                    element: textarea,
                    spellChecker: false,
                    toolbar: [
                        "bold", "italic", "strikethrough", "|", "quote", "code", "|", "unordered-list", "ordered-list", "|", "link", "image", "|", "preview", "fullscreen", "guide"
                    ],
                    forceSync: true,
                    placeholder: "Enter answer text here...",
                    status : false
                });
                editor.codemirror.on("change" , function() {
                    updateAnswerPreview();
                    scheduleAutoSave();
                });

                //Store editor reference for later access
                answerTextEditors.push({
                    textarea : textarea,
                    editor : editor,
                    answerId : textarea.name.replace('answer_text_' , '')
                });
            });
        }
        
        // Helper function to clean feedback text
        function cleanFeedbackText(feedback, answerText = '') {
            if (!feedback) return feedback;
            
            // Remove the answer text itself if it appears at the beginning
            if (answerText) {
                // Escape special regex characters in the answer text
                const escapedAnswerText = answerText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                // Remove answer text at the start, possibly followed by separators
                const answerTextRegex = new RegExp(`^\\s*${escapedAnswerText}\\s*[-–—:;.,]*\\s*`, 'i');
                feedback = feedback.replace(answerTextRegex, '');
            }
            
            return feedback
                .replace(/\(Weight:\s*\d+%?\)/gi, '')  // Remove (Weight: X%)
                .replace(/\[.*?(?:CORRECT|INCORRECT).*?\]/gi, '')  // Remove [✓ CORRECT] or [✗ INCORRECT]
                .replace(/✓\s*CORRECT\s*[:-]?/gi, '')  // Remove ✓ CORRECT
                .replace(/✗\s*INCORRECT\s*[:-]?/gi, '')  // Remove ✗ INCORRECT
                .replace(/^\s*\d+%?\s*[:-]?\s*/gm, '')  // Remove weight percentages at start of lines
                .replace(/[ \t]+/g, ' ')  // Clean up multiple spaces/tabs but preserve newlines
                .split('\n').map(line => line.trim()).join('\n')  // Trim each line
                .trim();  // Remove empty lines at start and end
        }
        
        // Function to initialize SimpleMDE for answer feedback textareas
        function initializeAnswerFeedbackEditors() {
            const feedbackTextareas = document.querySelectorAll('.answer-feedback-editor');
            feedbackTextareas.forEach((textarea, index) => {
                const editor = new SimpleMDE({
                    element: textarea,
                    spellChecker: false,
                    placeholder: "Enter feedback for this answer choice...",
                    toolbar: [
                        "bold", "italic", "|",
                        "unordered-list", "ordered-list", "|",
                        "link", "|",
                        {
                            name: "preview",
                            action: function customPreviewAction(editor) {
                                SimpleMDE.togglePreview(editor);
                                updatePreviewButton(editor);
                            },
                            className: "fa fa-eye no-disable active",
                            title: "Toggle Preview"
                        }
                    ],
                    status: false
                });
                
                // Add change listener for auto-save
                editor.codemirror.on("change", function() {
                    scheduleAutoSave();
                });
                
                // Store editor reference for later access
                answerFeedbackEditors.push({
                    textarea: textarea,
                    editor: editor,
                    answerId: textarea.name.replace('answer_comments_', '')
                });
            });
        }

        // Initialize editors when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize SimpleMDE for answer feedback textareas and for Answer text areas as well
            initializeAnswerTextEditors();
            initializeAnswerFeedbackEditors();
            
            // Initialize SimpleMDE for question text
            questionTextEditor = new SimpleMDE({
                element: document.getElementById("questionText"),
                spellChecker: false,
                placeholder: "Enter your question text here...",
                toolbar: [
                    "bold", "italic", "heading", "|",
                    "quote", "unordered-list", "ordered-list", "|",
                    "link", "code", "|",
                    {
                        name: "preview",
                        action: function customPreviewAction(editor) {
                            SimpleMDE.togglePreview(editor);
                            updatePreviewButton(editor);
                        },
                        className: "fa fa-eye no-disable active",
                        title: "Toggle Preview"
                    }, "guide"
                ],
                status: ["lines", "words", "cursor"]
            });
            
            // Initialize SimpleMDE for general feedback
            generalFeedbackEditor = new SimpleMDE({
                element: document.getElementById("generalFeedback"),
                spellChecker: false,
                placeholder: "Explain the importance and relevance of this question...",
                toolbar: [
                    "bold", "italic", "heading", "|",
                    "quote", "unordered-list", "ordered-list", "|",
                    "link", "code", "|",
                    {
                        name: "preview",
                        action: function customPreviewAction(editor) {
                            SimpleMDE.togglePreview(editor);
                            updatePreviewButton(editor);
                        },
                        className: "fa fa-eye no-disable active",
                        title: "Toggle Preview"
                    }, "guide"
                ],
                status: ["lines", "words", "cursor"]
            });
            
            // Add change listeners for auto-save and preview updates
            questionTextEditor.codemirror.on("change", function() {
                updateFullQuestionPreview();
                scheduleAutoSave();
            });
            generalFeedbackEditor.codemirror.on("change", scheduleAutoSave);
            
            // Add click listeners for correctness buttons
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('correctness-button')) {
                    handleCorrectnessToggle(e.target);
                }
            });
            
            // Initialize tags and objective preview on page load
            updateTagsPreview();
            updateObjectivePreview();
            
            // Don't overwrite the backend-rendered Question Preview on page load
            // updateFullQuestionPreview();
            
            // Manual save button for new questions
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            if (manualSaveBtn) {
                manualSaveBtn.addEventListener('click', function() {
                    console.log('Manual save triggered');
                    autoSave();
                });
            }
            
            // Delete button functionality
            const deleteBtn = document.getElementById('deleteQuestionBtn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', function() {
                    const questionId = deleteBtn.getAttribute('data-question-id');
                    showDeleteConfirmationModal(questionId);
                });
            }
            
            // Confirm delete button in modal
            const confirmDeleteBtn = document.getElementById('confirmDeleteBtn');
            if (confirmDeleteBtn) {
                confirmDeleteBtn.addEventListener('click', function() {
                    const questionId = confirmDeleteBtn.getAttribute('data-question-id');
                    if (questionId) {
                        deleteQuestion(questionId);
                    }
                });
            }
        });


        function getAnswerTextContent(answerId){
            const editorData = answerTextEditors.find(item => item.answerId == answerId);
            if(editorData && editorData.editor) {
                return editorData.editor.value();
            } else{
                const textarea = document.querySelector(`textarea[name="answer_text_${answerId}"]`);
                return textarea ? textarea.value : '';
            }
        }


        // Function to update preview button appearance based on current mode
        function updatePreviewButton(editor) {
            const toolbar = editor.toolbar;
            const previewButton = toolbar.find(item => item && item.name === 'preview');
            
            if (previewButton) {
                const isPreviewActive = editor.isPreviewActive();
                const buttonElement = previewButton;
                
                if (isPreviewActive) {
                    buttonElement.className = "fa fa-pencil no-disable";
                    buttonElement.title = "Edit (Currently in Preview)";
                } else {
                    buttonElement.className = "fa fa-eye no-disable";
                    buttonElement.title = "Preview (Currently in Edit)";
                }
            }
        }

        // Handle correctness toggle for answer options
        function handleCorrectnessToggle(buttonElement) {
            console.log('Correctness toggle clicked');
            const answerId = buttonElement.getAttribute('data-answer-id');
            const questionType = buttonElement.getAttribute('data-question-type');
            const weightInput = document.querySelector(`input[name="answer_weight_${answerId}"]`);
            
            console.log('Answer ID:', answerId, 'Question Type:', questionType, 'Weight Input:', weightInput);
            
            if (!weightInput) {
                console.error('Weight input not found for answer ID:', answerId);
                return;
            }
            
            const currentWeight = parseFloat(weightInput.value) || 0;
            const isCurrentlyCorrect = currentWeight > 0;
            
            if (questionType === 'multiple_choice_question' || questionType === 'true_false_question') {
                // For multiple choice and true/false: only one answer can be correct
                // First, set all answers to incorrect (weight = 0)
                const allWeightInputs = document.querySelectorAll('.answer-weight');
                const allButtons = document.querySelectorAll('.correctness-button');
                
                allWeightInputs.forEach(input => {
                    input.value = '0';
                });
                
                allButtons.forEach(button => {
                    button.style.backgroundColor = '#dc3545'; // Red for incorrect
                    button.textContent = 'False';
                });
                
                // Then set the clicked answer as correct (weight = 100) if it wasn't already correct
                if (!isCurrentlyCorrect) {
                    weightInput.value = '100';
                    buttonElement.style.backgroundColor = '#28a745'; // Green for correct
                    buttonElement.textContent = 'True';
                }
                
            } else if (questionType === 'multiple_answers_question') {
                // For multiple answers: toggle individual answers
                if (isCurrentlyCorrect) {
                    // Make it incorrect
                    weightInput.value = '0';
                    buttonElement.style.backgroundColor = '#dc3545'; // Red for incorrect
                    buttonElement.textContent = 'False';
                } else {
                    // Make it correct
                    weightInput.value = '100';
                    buttonElement.style.backgroundColor = '#28a745'; // Green for correct
                    buttonElement.textContent = 'True';
                }
            }
            
            // Update the full question preview
            updateFullQuestionPreview();
            
            // Trigger auto-save
            scheduleAutoSave();
        }

        // Update question preview to reflect current answer correctness
        function updateQuestionPreview() {
            const previewItems = document.querySelectorAll('.answers-preview .list-group-item');
            const answerItems = document.querySelectorAll('.answer-item');
            
            answerItems.forEach((answerItem, index) => {
                const answerId = answerItem.dataset.answerId;
                const weightInput = document.querySelector(`input[name="answer_weight_${answerId}"]`);
                
                if (weightInput && previewItems[index]) {
                    const weight = parseFloat(weightInput.value) || 0;
                    const isCorrect = weight > 0;
                    
                    // Update the icon
                    const icon = previewItems[index].querySelector('i');
                    if (icon) {
                        if (isCorrect) {
                            icon.className = 'fas fa-check-circle text-success';
                        } else {
                            icon.className = 'fas fa-circle text-muted';
                        }
                    }
                    
                    // Update the weight badge
                    const badge = previewItems[index].querySelector('.badge');
                    if (badge) {
                        badge.textContent = `${weight}%`;
                    }
                }
            });
        }
        
        function updateTopicPreview() {
            const topicSelect = document.getElementById('topicSelect');
            const topicPreview = document.getElementById('topicPreview');
            
            if (topicSelect && topicPreview) {
                const selectedOption = topicSelect.options[topicSelect.selectedIndex];
                const topicLabel = selectedOption.text;
                topicPreview.innerHTML = `<i class="fas fa-tag"></i> ${topicLabel}`;
            }
        }
        
        function showTagSuggestions() {
            const currentValue = tagsInput.value;
            const lastCommaIndex = currentValue.lastIndexOf(',');
            const currentTag = (lastCommaIndex >= 0 ? currentValue.slice(lastCommaIndex + 1) : currentValue).trim().toLowerCase();
            
            // Filter existing tags based on current input
            const filteredTags = existingTags.filter(tag => 
                tag.toLowerCase().includes(currentTag) && 
                !getCurrentTags().includes(tag)
            );
            
            if (filteredTags.length > 0 && currentTag.length > 0) {
                tagSuggestions.innerHTML = filteredTags.map(tag => 
                    `<div class="tag-suggestion px-3 py-2 border-bottom cursor-pointer hover:bg-light" style="cursor: pointer;">${tag}</div>`
                ).join('');
                tagSuggestions.style.display = 'block';
            } else {
                tagSuggestions.style.display = 'none';
            }
        }
        
        function getCurrentTags() {
            const currentValue = tagsInput.value;
            return currentValue.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
        }
        
        function addTagToInput(tag) {
            const currentValue = tagsInput.value;
            const lastCommaIndex = currentValue.lastIndexOf(',');
            
            let newValue;
            if (lastCommaIndex >= 0) {
                // Replace the partial tag after the last comma
                newValue = currentValue.slice(0, lastCommaIndex + 1) + ' ' + tag;
            } else {
                // Replace the entire input if no comma exists
                newValue = tag;
            }
            
            tagsInput.value = newValue;
            tagSuggestions.style.display = 'none';
            tagsInput.focus();
            
            // Move cursor to end
            tagsInput.setSelectionRange(tagsInput.value.length, tagsInput.value.length);
            
            updateTagsPreview();
            scheduleAutoSave();
        }
        
        function updateTagsPreview() {
            const tagsPreview = document.getElementById('tagsPreview');
            if (tagsPreview) {
                const tags = getCurrentTags();
                if (tags.length > 0) {
                    tagsPreview.innerHTML = tags.map(tag => 
                        `<span class="badge bg-secondary me-1">${tag}</span>`
                    ).join('');
                    tagsPreview.style.display = 'inline';
                } else {
                    tagsPreview.style.display = 'none';
                }
            }
        }
        
        function updateObjectivePreview() {
            const learningObjectiveSelect = document.getElementById('learningObjectiveSelect');
            const objectivePreview = document.getElementById('objectivePreview');
            
            if (learningObjectiveSelect && objectivePreview) {
                const selectedValue = learningObjectiveSelect.value;
                if (selectedValue && selectedValue !== '') {
                    const selectedOption = learningObjectiveSelect.options[learningObjectiveSelect.selectedIndex];
                    const objectiveNumber = parseInt(selectedValue) + 1;
                    objectivePreview.innerHTML = `<span class="badge bg-warning text-dark"><i class="fas fa-bullseye"></i> Obj ${objectiveNumber}</span>`;
                    objectivePreview.style.display = 'inline';
                } else {
                    objectivePreview.style.display = 'none';
                }
            }
        }

        // Debug content sources for comparison
        function debugContentSources() {
            console.log('=== CONTENT SOURCE COMPARISON ===');
            
            // Get template content (Question Details source)
            const templateContent = document.querySelector('.question-text-preview').innerHTML;
            console.log('Template content (Question Details):', JSON.stringify(templateContent));
            
            // Get SimpleMDE content (Question Preview source)
            const simpleMDEContent = questionTextEditor.value();
            console.log('SimpleMDE content (Question Preview):', JSON.stringify(simpleMDEContent));
            
            // Get raw textarea content for comparison
            const textareaContent = document.getElementById('questionText').value;
            console.log('Raw textarea content:', JSON.stringify(textareaContent));
            
            console.log('Content lengths - Template:', templateContent.length, 'SimpleMDE:', simpleMDEContent.length, 'Textarea:', textareaContent.length);
            console.log('=== END CONTENT COMPARISON ===');
        }

        // Convert Markdown to HTML for preview display
        function convertMarkdownToHtml(markdown){
            if (!markdown) return '';
            let html = markdown;
            
            html = html.replace(/```(html)?\n([\s\S]*?)\n```/g, function(match, lang, code){
                const escapedCode = escapeHtml(code);
                return `<pre><code>${escapedCode}</code></pre>`;
            });
            
            html = html.replace(/`([^`\n]+)`/g, function(match, code){
                const escapedCode = escapeHtml(code);
                return `<code>${escapedCode}</code>`;
            });

            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');

            const parts = html.split(/(<pre><code>[\s\S]*?<\/code><\/pre>)/);
            html = parts.map((part , index) => {
                if (index % 2 == 0) {
                    return part.replace(/\n/g, '<br>');
                } else {
                    return part;
                }
            }).join('');

            html = html.replace(/<br>\s*<pre>/g, '<pre>');
            html = html.replace(/<\/pre>\s*<br>/g, '</pre>');

            return html;

        }

        // Update the entire question preview when changes are made
        function updateFullQuestionPreview() {
            // Update question text preview
            const questionText = questionTextEditor.value();
            const questionTextPreview = document.querySelector('.question-text-preview');
            
            if (questionTextPreview) {
                // Convert Markdown to HTML for proper preview display
                const htmlContent = convertMarkdownToHtml(questionText);
                questionTextPreview.innerHTML = htmlContent;
            }
            
            // Update topic, tags, and objective previews
            updateTopicPreview();
            updateTagsPreview();
            updateObjectivePreview();
            
            // Update answer previews
            updateAnswerPreview();
        }
        
        // Update answer preview specifically
        function updateAnswerPreview() {
            const answerItems = document.querySelectorAll('.answer-item');
            const answerPreviewList = document.querySelector('.answers-preview .list-group');
            
            if (!answerPreviewList) return;
            
            // Clear existing preview items
            answerPreviewList.innerHTML = '';
            
            answerItems.forEach((item, index) => {
                const answerId = item.dataset.answerId;
                const answerMarkdown = getAnswerTextContent(answerId);
                const weightInput = item.querySelector(`input[name="answer_weight_${answerId}"]`);
                const answerHtml = convertMarkdownToHtml(answerMarkdown);


                
                if (answerMarkdown) {
                    const weight = weightInput ? parseFloat(weightInput.value) || 0 : 0;
                    const isCorrect = weight > 0;
                    
                    // Create preview item
                    const previewItem = document.createElement('div');
                    previewItem.className = 'list-group-item d-flex justify-content-between align-items-start';
                    
                    previewItem.innerHTML = `
                        <div class="ms-2 me-auto">
                            <div class="fw-bold">
                                <i class="fas ${isCorrect ? 'fa-check-circle text-success' : 'fa-circle text-muted'}"></i>
                                ${answerHtml}
                            </div>
                        </div>
                        <span class="badge bg-primary rounded-pill">${weight}%</span>
                    `;
                    
                    answerPreviewList.appendChild(previewItem);
                }
            });
        }

        // Generate AI Feedback
        document.getElementById('generateFeedbackBtn').addEventListener('click', async () => {
            if (isGeneratingFeedback) return;
            
            const btn = document.getElementById('generateFeedbackBtn');
            const originalText = btn.innerHTML;
            
            console.log('=== AI Feedback Generation Started ===');
            console.log('Question ID:', questionId);
            console.log('Current Question ID:', currentQuestionId);
            console.log('Is New Question:', isNewQuestion);
            console.log('Button clicked, starting feedback generation...');
            
            isGeneratingFeedback = true;
            btn.disabled = true;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
            
            try {
                // Check if the question has content before proceeding
                const questionText = questionTextEditor.value().trim();
                if (!questionText) {
                    showErrorMessage('Please enter question text before generating feedback.');
                    return;
                }
                
                let targetQuestionId = currentQuestionId;
                
                // If this is a new question, we need to save it first to get a real ID
                if (isNewQuestion && currentQuestionId === 'new') {
                    console.log('New question detected, saving first to get ID...');
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving question...';
                    
                    // Collect form data and save the question
                    const formData = collectFormData();
                    console.log('Form data collected for saving:', formData);
                    
                    const saveResponse = await fetch('/questions/new', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(formData)
                    });
                    
                    if (!saveResponse.ok) {
                        const error = await saveResponse.json();
                        throw new Error(`Failed to save question: ${error.detail || 'Unknown error'}`);
                    }
                    
                    const saveResult = await saveResponse.json();
                    console.log('Question saved successfully:', saveResult);
                    
                    // Update the current question ID
                    targetQuestionId = saveResult.question_id;
                    currentQuestionId = targetQuestionId;
                    isNewQuestion = false;
                    
                    console.log('Updated current question ID to:', targetQuestionId);
                    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating feedback...';
                }
                
                const requestUrl = `/questions/${targetQuestionId}/generate-feedback`;
                console.log('Making feedback request to:', requestUrl);
                
                const response = await fetch(requestUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', Object.fromEntries(response.headers.entries()));
                
                const result = await response.json();
                console.log('Response data:', result);
                
                if (response.ok) {
                    console.log('✅ Feedback generated successfully');
                    console.log('Generated feedback:', result.feedback);
                    
                    // Log token usage information
                    if (result.feedback.token_usage) {
                        console.log('🔢 === AI Token Usage ===');
                        console.log('📝 Prompt tokens:', result.feedback.token_usage.prompt_tokens);
                        console.log('🤖 Completion tokens:', result.feedback.token_usage.completion_tokens);
                        console.log('📊 Total tokens:', result.feedback.token_usage.total_tokens);
                        
                        // Calculate cost for GPT-4o mini
                        const inputCost = (result.feedback.token_usage.prompt_tokens / 1000) * 0.000150;
                        const outputCost = (result.feedback.token_usage.completion_tokens / 1000) * 0.000600;
                        const totalCost = inputCost + outputCost;
                        
                        console.log('💰 Cost breakdown (GPT-4o mini):');
                        console.log('   Input cost:', `$${inputCost.toFixed(6)}`);
                        console.log('   Output cost:', `$${outputCost.toFixed(6)}`);
                        console.log('   Total cost:', `$${totalCost.toFixed(6)}`);
                        console.log('========================');
                    }
                    
                    // Update the general feedback field
                    if (result.feedback.general_feedback) {
                        generalFeedbackEditor.value(result.feedback.general_feedback);
                        console.log('Updated general feedback field');
                    }
                    
                    // Update answer-specific feedback fields
                    if (result.feedback.answer_feedback) {
                        console.log('Updating answer feedback fields...');
                        console.log('Available answer feedback keys:', Object.keys(result.feedback.answer_feedback));
                        
                        const answerItems = document.querySelectorAll('.answer-item');
                        console.log(`Found ${answerItems.length} answer items`);
                        
                        answerItems.forEach((item, index) => {
                            const answerId = item.dataset.answerId;
                            const answerNumber = index + 1;
                            
                            console.log(`Processing answer ${answerNumber} (ID: ${answerId})`);
                            
                            // Try different keys to match the feedback
                            const possibleKeys = [
                                `answer ${answerNumber}`,
                                `answer${answerNumber}`,
                                `${answerNumber}`,
                                answerNumber.toString(),
                                `answer ${answerNumber}:`, // In case the parsing included colon
                                `answer${answerNumber}:`
                            ];
                            
                            let feedbackFound = false;
                            for (const key of possibleKeys) {
                                // console.log(`Trying key: "${key}"`);
                                if (result.feedback.answer_feedback[key]) {
                                    // Get the answer text for this answer
                                    const answerTextInput = item.querySelector(`textarea[name="answer_text_${answerId}"]`);
                                    const answerText = answerTextInput ? answerTextInput.value : '';
                                    
                                    const feedbackResult = cleanFeedbackText(result.feedback.answer_feedback[key], answerText);
                                    console.log(`Adding feedback for answer ${answerNumber}: ${feedbackResult}`);
                                    
                                    // Try to set content in SimpleMDE editor first
                                    const editorData = answerFeedbackEditors.find(item => item.answerId === answerId);
                                    if (editorData && editorData.editor) {
                                        editorData.editor.value(feedbackResult);
                                        console.log(`✅ Updated SimpleMDE editor for answer ${answerNumber} with key "${key}"`);
                                        feedbackFound = true;
                                        break;
                                    } else {
                                        // Fallback to textarea
                                        const feedbackField = document.querySelector(`textarea[name="answer_comments_${answerId}"]`);
                                        if (feedbackField) {
                                            feedbackField.value = feedbackResult;
                                            console.log(`✅ Updated feedback textarea for answer ${answerNumber} with key "${key}"`);
                                            feedbackFound = true;
                                            break;
                                        } else {
                                            console.warn(`⚠️ Feedback field not found for answer ${answerId}`);
                                        }
                                    }
                                }
                            }
                            
                            if (!feedbackFound) {
                                console.warn(`⚠️ No feedback found for answer ${answerNumber}`);
                                // Try to match by looking for any key that contains the answer number
                                for (const [key, value] of Object.entries(result.feedback.answer_feedback)) {
                                    if (key.includes(answerNumber.toString())) {
                                        // Get the answer text for this answer
                                        const answerTextInput = item.querySelector(`textarea[name="answer_text_${answerId}"]`);
                                        const answerText = answerTextInput ? answerTextInput.value : '';
                                        
                                        const cleanedValue = cleanFeedbackText(value, answerText);
                                        console.log(`Adding feedback for answer ${answerNumber}: ${cleanedValue}`);
                                        
                                        // Try to set content in SimpleMDE editor first
                                        const editorData = answerFeedbackEditors.find(item => item.answerId === answerId);
                                        if (editorData && editorData.editor) {
                                            editorData.editor.value(cleanedValue);
                                            console.log(`✅ Updated SimpleMDE editor for answer ${answerNumber} with partial match key "${key}"`);
                                            break;
                                        } else {
                                            // Fallback to textarea
                                            const feedbackField = document.querySelector(`textarea[name="answer_comments_${answerId}"]`);
                                            if (feedbackField) {
                                                feedbackField.value = cleanedValue;
                                                console.log(`✅ Updated feedback textarea for answer ${answerNumber} with partial match key "${key}"`);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        });
                    }
                    
                    // Trigger auto-save
                    scheduleAutoSave();
                    console.log('Auto-save scheduled');
                    
                    // Show appropriate success message
                    if (isNewQuestion && currentQuestionId !== 'new') {
                        showSuccessMessage(`Question saved and AI feedback generated successfully! Question ID: ${currentQuestionId}`);
                    } else {
                        showSuccessMessage('AI feedback generated successfully!');
                    }
                } else {
                    console.error('❌ Failed to generate feedback');
                    console.error('Error details:', result.detail || result.message || 'Unknown error');
                    showErrorMessage(result.detail || result.message || 'Failed to generate feedback');
                }
            } catch (error) {
                console.error('❌ Exception during feedback generation:', error);
                console.error('Error type:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showErrorMessage('Error generating feedback: ' + error.message);
            } finally {
                console.log('=== AI Feedback Generation Completed ===');
                btn.disabled = false;
                btn.innerHTML = originalText;
                isGeneratingFeedback = false;
            }
        });

        // Auto-save functionality
        function scheduleAutoSave() {
            if (saveTimeout) {
                clearTimeout(saveTimeout);
            }
            
            console.log('Auto-save scheduled. Is new question:', isNewQuestion, 'Current ID:', currentQuestionId);
            
            // For new questions, save immediately after a shorter delay
            const delay = (isNewQuestion && currentQuestionId === 'new') ? 500 : 1000;
            saveTimeout = setTimeout(autoSave, delay);
        }

        async function autoSave() {
            if (isSaving) return;
            
            console.log('Starting auto-save...');
            isSaving = true;
            const formData = collectFormData();
            console.log('Form data collected:', formData);
            
            try {
                let url, method;
                if (isNewQuestion && currentQuestionId === 'new') {
                    // Creating a new question
                    url = '/questions/new';
                    method = 'POST';
                    console.log('Creating new question with POST to:', url);
                } else {
                    // Updating existing question
                    url = `/questions/${currentQuestionId}`;
                    method = 'PUT';
                    console.log('Updating existing question with PUT to:', url);
                }
                
                console.log('Sending request:', method, url, formData);
                const response = await fetch(url, {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                console.log('Response status:', response.status);
                if (response.ok) {
                    const result = await response.json();
                    console.log('Save successful:', result);
                    showAutoSaveIndicator();
                    
                    // If it was a new question, update the current question ID and show options
                    if (isNewQuestion && currentQuestionId === 'new' && result.question_id) {
                        console.log('New question created with ID:', result.question_id);
                        currentQuestionId = result.question_id;
                        isNewQuestion = false;
                        
                        // Show success message with navigation options
                        showQuestionCreatedAlert(result.question_id);
                    }
                } else {
                    const error = await response.json();
                    console.error('Save failed:', error);
                    showAlert('danger', `Save failed: ${error.detail || 'Unknown error'}`);
                }
            } catch (error) {
                console.error('Save error:', error);
                showAlert('danger', `Save error: ${error.message}`);
            } finally {
                isSaving = false;
            }
        }
        
        // Helper function to get content from SimpleMDE editor for specific answer
        function getAnswerFeedbackContent(answerId) {
            // Find the SimpleMDE editor for this answer
            const editorData = answerFeedbackEditors.find(item => item.answerId === answerId);
            if (editorData && editorData.editor) {
                return editorData.editor.value();
            } else {
                // Fallback to textarea value if editor not found
                const textarea = document.querySelector(`textarea[name="answer_comments_${answerId}"]`);
                return textarea ? textarea.value : '';
            }
        }

        function collectFormData() {
            const form = document.getElementById('questionForm');
            const formData = new FormData(form);
            
            // Collect basic question data - use SimpleMDE values
            const data = {
                question_text: questionTextEditor.value() || '',
                topic: document.getElementById('topicSelect')?.value || 'general',
                tags: document.getElementById('tagsInput')?.value || '',
                learning_objective: document.getElementById('learningObjectiveSelect')?.value || '',
                correct_comments: '',  // Not used in new design
                incorrect_comments: '',  // Not used in new design
                neutral_comments: generalFeedbackEditor.value() || '',  // General feedback
                correct_comments_html: '',
                incorrect_comments_html: '',
                neutral_comments_html: '',
                answers: []
            };

            // Collect answers data
            const answerItems = document.querySelectorAll('.answer-item');
            answerItems.forEach(item => {
                const answerId = item.dataset.answerId;
                const answer = {
                    id: parseInt(answerId),
                    text : getAnswerTextContent(answerId) || '',
                    html: formData.get(`answer_html_${answerId}`) || '',
                    comments: getAnswerFeedbackContent(answerId) || '',
                    comments_html: formData.get(`answer_comments_html_${answerId}`) || ''
                };
                
                // Only add weight for non-matching questions
                const weightInput = document.querySelector(`input[name="answer_weight_${answerId}"]`);
                if (weightInput) {
                    answer.weight = parseFloat(formData.get(`answer_weight_${answerId}`)) || 0;
                }
                
                // Add right side for matching questions
                const rightField = formData.get(`answer_right_${answerId}`);
                if (rightField) {
                    answer.right = rightField;
                }
                
                data.answers.push(answer);
            });

            return data;
        }

        function showAutoSaveIndicator() {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
            }, 2000);
        }
        
        // Show alert function
        function showAlert(type, message) {
            // Create alert container if it doesn't exist
            let alertContainer = document.getElementById('alertContainer');
            if (!alertContainer) {
                alertContainer = document.createElement('div');
                alertContainer.id = 'alertContainer';
                document.querySelector('.container-fluid').insertBefore(alertContainer, document.querySelector('.container-fluid').firstChild);
            }
            
            const alert = document.createElement('div');
            alert.className = `alert alert-${type} alert-dismissible fade show`;
            alert.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            alertContainer.appendChild(alert);
            
            setTimeout(() => {
                if (alert.parentNode) {
                    alert.remove();
                }
            }, 5000);
        }
        
        // Show question created alert with navigation options
        function showQuestionCreatedAlert(questionId) {
            // Create alert container if it doesn't exist
            let alertContainer = document.getElementById('alertContainer');
            if (!alertContainer) {
                alertContainer = document.createElement('div');
                alertContainer.id = 'alertContainer';
                document.querySelector('.container-fluid').insertBefore(alertContainer, document.querySelector('.container-fluid').firstChild);
            }
            
            const alert = document.createElement('div');
            alert.className = 'alert alert-success alert-dismissible fade show';
            alert.innerHTML = `
                <h6 class="alert-heading">
                    <i class="fas fa-check-circle"></i> Question Created Successfully!
                </h6>
                <p class="mb-3">Your question has been saved with ID: <strong>${questionId}</strong></p>
                <div class="d-flex gap-2">
                    <button type="button" class="btn btn-primary btn-sm" onclick="window.location.href='/questions/${questionId}'">
                        <i class="fas fa-edit"></i> Continue Editing
                    </button>
                    <button type="button" class="btn btn-outline-primary btn-sm" onclick="window.location.href='/?t=' + Date.now()">
                        <i class="fas fa-list"></i> Back to Question List
                    </button>
                    <button type="button" class="btn btn-success btn-sm" onclick="window.location.href='/questions/new'">
                        <i class="fas fa-plus"></i> Create Another Question
                    </button>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            alertContainer.appendChild(alert);
            
            // Update the current page to reflect the question has been created
            updatePageForCreatedQuestion(questionId);
        }
        
        // Update the page UI to reflect that the question has been created
        function updatePageForCreatedQuestion(questionId) {
            // Update the header
            const header = document.querySelector('h1.h2');
            if (header) {
                header.innerHTML = `
                    <i class="fas fa-edit text-primary"></i> Edit Question
                    <small class="text-muted fs-6">(Question ID: ${questionId})</small>
                `;
            }
            
            // Update the question ID field
            const questionIdInput = document.querySelector('input[readonly]');
            if (questionIdInput && questionIdInput.value.includes('Will be assigned')) {
                questionIdInput.value = questionId;
            }
            
            // Hide the manual save button
            const manualSaveBtn = document.getElementById('manualSaveBtn');
            if (manualSaveBtn) {
                manualSaveBtn.style.display = 'none';
            }
            
            // Update the progress/info container
            const progressContainer = document.querySelector('.progress-container');
            if (progressContainer && progressContainer.querySelector('.alert-info')) {
                progressContainer.innerHTML = `
                    <div class="alert alert-success">
                        <h6 class="alert-heading">
                            <i class="fas fa-check-circle"></i> Question Saved
                        </h6>
                        <p class="mb-0">Question has been created and saved. You can continue editing or navigate to other questions.</p>
                    </div>
                `;
            }
        }

        function showSuccessMessage(message) {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.innerHTML = `
                <div class="alert alert-success alert-sm mb-0">
                    <i class="fas fa-check"></i> ${message}
                </div>
            `;
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
                indicator.innerHTML = `
                    <div class="alert alert-success alert-sm mb-0">
                        <i class="fas fa-check"></i> Saved
                    </div>
                `;
            }, 3000);
        }

        function showErrorMessage(message) {
            const indicator = document.getElementById('autoSaveIndicator');
            indicator.innerHTML = `
                <div class="alert alert-danger alert-sm mb-0">
                    <i class="fas fa-exclamation-triangle"></i> ${message}
                </div>
            `;
            indicator.style.display = 'block';
            setTimeout(() => {
                indicator.style.display = 'none';
                indicator.innerHTML = `
                    <div class="alert alert-success alert-sm mb-0">
                        <i class="fas fa-check"></i> Saved
                    </div>
                `;
            }, 5000);
        }
        
        // Delete question functionality
        function showDeleteConfirmationModal(questionId) {
            // Populate question summary in modal
            const questionText = questionTextEditor.value();
            const summary = document.getElementById('deleteQuestionSummary');
            
            summary.innerHTML = `
                <div class="mb-2">
                    <strong>Question ID:</strong> ${questionId}
                </div>
                <div class="mb-2">
                    <strong>Question Text:</strong> ${questionText.substring(0, 200)}${questionText.length > 200 ? '...' : ''}
                </div>
                <div class="mb-2">
                    <strong>Type:</strong> {{ question.question_type.replace('_', ' ').title() }}
                </div>
                <div class="mb-2">
                    <strong>Points:</strong> {{ question.points_possible }}
                </div>
            `;
            
            // Set the question ID on the confirm button
            const confirmBtn = document.getElementById('confirmDeleteBtn');
            confirmBtn.setAttribute('data-question-id', questionId);
            
            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('deleteQuestionModal'));
            modal.show();
        }
        
        async function deleteQuestion(questionId) {
            const confirmBtn = document.getElementById('confirmDeleteBtn');
            const originalText = confirmBtn.innerHTML;
            
            console.log('Starting question deletion for ID:', questionId);
            
            // Show loading state
            confirmBtn.disabled = true;
            confirmBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting...';
            
            try {
                const response = await fetch(`/questions/${questionId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                console.log('Delete response status:', response.status);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('Question deleted successfully:', result);
                    
                    // Hide the modal
                    const modal = bootstrap.Modal.getInstance(document.getElementById('deleteQuestionModal'));
                    modal.hide();
                    
                    // Show success message and redirect to home page
                    showAlert('success', 'Question deleted successfully!');
                    
                    // Redirect to home page after a short delay
                    setTimeout(() => {
                        window.location.href = '/';
                    }, 1500);
                    
                } else {
                    const error = await response.json();
                    console.error('Delete failed:', error);
                    showAlert('danger', `Failed to delete question: ${error.detail || 'Unknown error'}`);
                    
                    // Reset button state
                    confirmBtn.disabled = false;
                    confirmBtn.innerHTML = originalText;
                }
                
            } catch (error) {
                console.error('Delete error:', error);
                showAlert('danger', `Error deleting question: ${error.message}`);
                
                // Reset button state
                confirmBtn.disabled = false;
                confirmBtn.innerHTML = originalText;
            }
        }

        // Add event listeners for auto-save
        document.getElementById('questionForm').addEventListener('input', scheduleAutoSave);
        document.getElementById('questionForm').addEventListener('change', scheduleAutoSave);
        
        // Topic dropdown change handler
        const topicSelect = document.getElementById('topicSelect');
        if (topicSelect) {
            topicSelect.addEventListener('change', function() {
                updateTopicPreview();
                scheduleAutoSave();
            });
        }
        
        // Learning objective dropdown change handler
        const learningObjectiveSelect = document.getElementById('learningObjectiveSelect');
        if (learningObjectiveSelect) {
            learningObjectiveSelect.addEventListener('change', function() {
                updateObjectivePreview();
                scheduleAutoSave();
            });
        }
        
        // Tag input functionality
        const tagsInput = document.getElementById('tagsInput');
        const tagSuggestions = document.getElementById('tagSuggestions');
        const existingTags = {{ existing_tags | tojson | safe }};
        
        if (tagsInput && tagSuggestions) {
            // Show suggestions on focus and input
            tagsInput.addEventListener('input', function() {
                showTagSuggestions();
                updateTagsPreview();
                scheduleAutoSave();
            });
            
            tagsInput.addEventListener('focus', function() {
                showTagSuggestions();
            });
            
            // Hide suggestions when clicking outside
            document.addEventListener('click', function(e) {
                if (!tagsInput.contains(e.target) && !tagSuggestions.contains(e.target)) {
                    tagSuggestions.style.display = 'none';
                }
            });
            
            // Handle tag suggestions
            tagSuggestions.addEventListener('click', function(e) {
                if (e.target.classList.contains('tag-suggestion')) {
                    addTagToInput(e.target.textContent);
                }
            });
        }

        // Handle textarea changes - specifically watch for answer text changes
        document.querySelectorAll('textarea').forEach(textarea => {
            textarea.addEventListener('input', function() {
                // If this is an answer text field, update the preview
                if (textarea.name && textarea.name.startsWith('answer_text_')) {
                    updateAnswerPreview();
                }
                scheduleAutoSave();
            });
            textarea.addEventListener('blur', scheduleAutoSave);
        });

        // Prevent form submission
        document.getElementById('questionForm').addEventListener('submit', (e) => {
            e.preventDefault();
        });

        // Keyboard navigation
        //document.addEventListener('keydown', (e) => {
//            // Only handle keyboard shortcuts if not focused on an input/textarea
//            if (document.activeElement.tagName === 'INPUT' ||
//                document.activeElement.tagName === 'TEXTAREA') {
//                return;
//            }

//            // Ctrl/Cmd + Left Arrow = Previous question
//            if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowLeft') {
//                e.preventDefault();
//                const prevBtn = document.getElementById('prevBtn');
//                if (prevBtn && !prevBtn.disabled) {
//                    prevBtn.click();
//                }
//            }

//            // Ctrl/Cmd + Right Arrow = Next question
//            if ((e.ctrlKey || e.metaKey) && e.key === 'ArrowRight') {
//                e.preventDefault();
//                const nextBtn = document.getElementById('nextBtn');
//                if (nextBtn && !nextBtn.disabled) {
//                    nextBtn.click();
//                }
//            }

//            // Escape = Back to list
//            if (e.key === 'Escape') {
//                e.preventDefault();
//                window.location.href = '/';
//            }
//        });

//        // Add keyboard shortcut hints
//        const helpText = document.createElement('div');
//        helpText.className = 'alert alert-light mt-4';
//        helpText.innerHTML = `
//            <small class="text-muted">
//                <strong>Keyboard shortcuts:</strong>
//                <kbd>Ctrl</kbd>+<kbd>←</kbd> Previous question •
//                <kbd>Ctrl</kbd>+<kbd>→</kbd> Next question •
//                <kbd>Esc</kbd> Back to list
//            </small>
//        `;
//        document.querySelector('.container-fluid').appendChild(helpText);
    </script>
</body>
</html>